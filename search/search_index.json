{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"git/","title":"Git Guide","text":""},{"location":"git/#what","title":"What?","text":"<p>Git is a version control system.  It allows teams to collaborate on a project. Git is considered to be the industry standard  version control system.</p>"},{"location":"git/#guide","title":"Guide","text":""},{"location":"git/#1-setup","title":"1) Setup","text":"<ul> <li>macos: <code>brew install git</code></li> <li>ubuntu: <code>sudo apt-get install git</code></li> <li>fedora: <code>sudo dnf install git</code></li> <li>windows: download from https://gitforwindows.org/ and run the installer</li> </ul>"},{"location":"git/#2-basic-configuration","title":"2) Basic configuration","text":"<ul> <li> <p>set global name and email (optional)</p> <p>git config --global user.name \"John Doe\"</p> <p>git config --global user.email \"john.doe@example.com\"</p> </li> </ul> <p>All commits will show the name and email configured. This will apply for all repositories on your computer.</p> <ul> <li> <p>set local name and email (recommended)</p> <p>git config user.name \"John Doe\"</p> <p>git config user.email \"john.doe@example.com\"</p> </li> </ul> <p>Same as the global one but it only applies to the current directory. This will make it possible to configure different emails/names for different projects(=clients).</p>"},{"location":"git/#3-basic-commands","title":"3) basic commands","text":"<p>Your IDE does a lot for you but it pays to know the cli commands.</p> <ul> <li><code>git fetch</code> fetches the latest state of the branches. You then know if you need to pull any changes</li> <li><code>git status</code> shows the files which are staged for commit, shows files which aren't added to git and shows if the current branch is behind/ahead of the remote branch on the server.</li> <li><code>git branch</code> makes a new branch from the current branch</li> <li><code>git checkout</code> checks out a specific branch</li> <li><code>git pull</code> pulls the latest commits on the server into your branch.</li> <li><code>git add {path}</code> stages files to be committed.</li> <li><code>git commit -m \"{message}\"</code> commits the files which are staged for commit.</li> <li><code>git push</code> pushes the local commits to the remote branch.</li> </ul>"},{"location":"git/#4-advanced-commands","title":"4) Advanced commands","text":"<ul> <li><code>git push --force-with-lease</code> this force pushes the current branch with rewritten history to the remote. (dangerous if you don't know what you are doing)</li> <li><code>git rebase</code> (will be explained in a section below)</li> </ul>"},{"location":"git/#5-process-of-developing-a-feature","title":"5) Process of developing a feature","text":"<ul> <li>Checkout a release branch where you want to start from</li> <li>Develop the feature</li> <li>Add the new files to git with <code>git add</code> or via the IDE</li> <li>Commit the changes to the local branch with <code>git commit -m {message}</code> or via the IDE</li> <li>The first line of the commit should be the ticket number with a oneliner describing the ticket. for example <code>XPLR-100 Add OrderEndpoint</code></li> <li>Below the first line you can do what you want to describe what you did, why you did it, ... (look at my favourite git commit)</li> <li>If needed make multiple commits if it makes sense</li> <li><code>git push</code> or via the IDE</li> </ul>"},{"location":"git/#6-tips","title":"6) Tips","text":"<ul> <li>It's possible to encounter a bug during development which isn't related to your ticket. If this is the case you can fix it and commit it to a separate commit. Doing this makes it possible to revert the ticket but still apply the fix for the bug you found.</li> <li>Make a new ticket and place it on the backlog if the time requirement is too large.</li> <li>Make sure each commit builds and runs.</li> <li>Don't have 200 commits for one feature (or only have 1 commit for a very large change)</li> <li>Check with your team if you want to squash all commits into one commit before merging.</li> </ul>"},{"location":"git/#7-advanced","title":"7) Advanced","text":"<p>It's possible to develop a feature and commit several times and in the end to redo the commits. You would do this to make your git history to show a story of the development. This makes it easier for another person to review your ticket as the small steps(=commits) make sense and are smaller bite sized chunks to review. Check this for more details.</p>"},{"location":"git/#8-git-rebase","title":"8) Git Rebase","text":"<p>You have made a new branch to develop a feature and after a couple of days you are finished. But in the meanwhile the main branch has continued as other developers finished/merged their changes. You now have 2 options to get the latest changes into your feature branch. <code>git merge</code> or <code>git rebase</code>. with </p>"},{"location":"git/#git-merge","title":"Git merge","text":"<p>You combine the changes from the main branch and your feature branch. Which most likely will be fixing numerous merge conflicts. In the git log you will see that you made a new Commit to merge them (see picture below). </p>"},{"location":"git/#git-rebase","title":"Git rebase","text":"<p>Imagine you have a main branch with having the last commit named A. When developing your feature you made commits B and C. Now you are finished but in the meanwhile commits D E and F have been applied on the main branch (because other developers merged their branches). With rebasing you take your commits B and C and put them at the end of the main branch.</p> <p>Before the rebase you had commits A B C in that order. When rebasing it would now be A D E F B C. Hopefully the picture below makes it a bit clearer.</p> <p></p> <p>You can do a lot more with <code>git rebase</code> like merging commits, reordering commits. Have a look it interactively rebase in your IDE (Intellij for sure has this) In the end you need to push your change with <code>git push --force-with-lease</code> (read warning below)</p>"},{"location":"git/#warning-on-git-rebase","title":"Warning on git rebase","text":"<p>You ARE rewriting history, you can get into trouble if you are not careful and override someone else's changes. Because of this its recommended to only use <code>git rebase</code> if you are the only one working on that given branch.</p>"},{"location":"resources/","title":"Useful Packages","text":""},{"location":"resources/#state-management","title":"State management","text":"<ul> <li>The Flutter docs contains an extensive list of possible packages.</li> </ul>"},{"location":"resources/#unit-testing","title":"Unit Testing","text":"<ul> <li> <p>clock This package provides a Clock class which encapsulates the notion of the \"current time\" and provides easy access to points relative to the current time. Different Clocks can have a different notion of the current time, and the default top-level clock's notion can be swapped out to reliably test timing-dependent code.</p> </li> <li> <p>fake_async This package provides a FakeAsync class, which makes it easy to deterministically test code that uses asynchronous features like Futures, Streams, Timers, and microtasks. It creates an environment in which the user can explicitly control Dart's notion of the \"current time\". When the time is advanced, FakeAsync fires all asynchronous events that are scheduled for that time period without actually needing the test to wait for real time to elapse.</p> </li> </ul>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Flutter Version Management fvm</li> <li>For Android scrcpy</li> </ul>"},{"location":"tools/#intellij-plugins","title":"IntelliJ plugins","text":"<ul> <li>bloc</li> <li>Dart</li> <li>Flutter</li> </ul>"}]}